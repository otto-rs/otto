---
description:
globs:
alwaysApply: false
---
# Otto Development Patterns

This document outlines key development patterns and best practices for working with the Otto codebase.

## Error Handling

Otto uses `eyre` for structured error reporting throughout the codebase. This provides:
- Rich error context with `.wrap_err()` and `.with_context()`
- Automatic error chaining and backtrace support
- Consistent error formatting across modules

```rust
use eyre::{Result, WrapErr};

fn parse_config(path: &Path) -> Result<Config> {
    std::fs::read_to_string(path)
        .wrap_err_with(|| format!("Failed to read config file: {}", path.display()))?
        .parse()
        .wrap_err("Failed to parse YAML configuration")
}
```

## Async Patterns

Otto's executor uses async/await patterns extensively:
- Task execution is fully async with `tokio`
- File operations use async I/O where possible
- Parallel execution managed through `tokio::spawn`

## Configuration Deserialization

Otto uses `serde` with custom deserializers for complex YAML structures:
- Task parameters have custom validation logic
- Environment variables support shell-style expansion
- Multi-line scripts preserve indentation correctly

## Testing Strategy

Otto has comprehensive test coverage:
- Unit tests for individual components
- Integration tests for full workflows
- Example configurations serve as integration test cases
- Property-based testing for complex parsing logic

## Module Organization

- **cfg/**: Configuration parsing and validation
- **cli/**: Command-line interface with nom parsing
- **executor/**: Task execution engine with async scheduling
- **main.rs**: Application entry point and workflow orchestration

## Performance Considerations

- Parallel task execution with configurable concurrency
- Incremental builds using file timestamp checking
- Efficient dependency graph resolution
- Lazy evaluation of expensive operations

## Git Command Usage

Git commands like `git diff`, `git log`, and `git show` should always be executed with `git --no-pager` to prevent hanging the terminal when output is long. This is especially important in automated environments where the pager cannot be interacted with.

Examples:
- Use `git --no-pager diff` instead of `git diff`
- Use `git --no-pager log` instead of `git log`
- Use `git --no-pager show` instead of `git show`

This prevents the terminal from hanging when these commands produce output that would normally trigger a pager.

## Code Style

- Use `#[must_use]` on functions that return important values
- Prefer `eyre::Result<T>` over `std::result::Result<T, E>`
- Use `Arc<T>` for shared immutable data across async tasks
- Implement `Default` trait where appropriate for configuration structs
