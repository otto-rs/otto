---
description:
globs:
alwaysApply: false
---
# Otto Architecture Overview

Otto is a sophisticated make-like task runner written in Rust with YAML configuration. It features async execution, file dependencies, incremental builds, and parallel task execution.

## Core Architecture

### Module Structure
- **[src/cfg/](mdc:src/cfg)** - Configuration parsing and YAML deserialization
- **[src/cli/](mdc:src/cli)** - Command-line interface and argument parsing
- **[src/executor/](mdc:src/executor)** - Task execution engine with scheduling
- **[src/main.rs](mdc:src/main.rs)** - Application entry point

### Key Entry Points
- **[src/lib.rs](mdc:src/lib.rs)** - Public API exports
- **[src/main.rs](mdc:src/main.rs)** - Main application flow
- **[src/cli/parse.rs](mdc:src/cli/parse.rs)** - CLI parsing logic (large, 2000+ lines)

## Configuration System

Otto uses YAML configuration files with sophisticated features:
- Task dependencies (`before`/`after`)
- File dependencies with glob support
- Parameter definitions with validation
- Environment variable handling
- Multi-line script support

See [examples/ex1/otto.yml](mdc:examples/ex1/otto.yml) for basic usage patterns.

## Execution Engine

The executor handles:
- DAG-based dependency resolution
- Parallel async execution
- File timestamp checking for incremental builds
- Task classification (IO/CPU/Network bound)
- Output capture and workspace management

## Design Principles

1. **Type Safety** - Extensive use of serde for configuration parsing
2. **Async/Await** - Modern Rust patterns throughout
3. **Error Handling** - Uses `eyre` for structured error reporting
4. **Modularity** - Clear separation between parsing, config, and execution
5. **Testing** - Comprehensive test suite with integration tests

